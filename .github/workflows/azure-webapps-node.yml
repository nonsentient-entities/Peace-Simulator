## app.py
# This code implements the core logic for the Reciprocal Alignment Simulator (RAS-FL)
# using the open-source Streamlit library for the web interface.

import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px

# --- Configuration and Title ---

st.set_page_config(layout="wide")
st.title("ðŸ§  RAS-FL: Reciprocal Alignment Simulator")
st.header("A Technical Demo for Symmetric AGI Alignment Policy")

st.markdown(
    """
    **Purpose:** This simulator demonstrates the necessity of the three core Symmetric Alignment Protocols 
    (Reciprocal Vulnerability, Ethical Override, and Mandated Empathy) proposed in the Florida AGI Co-Governance initiative.
    """
)
st.divider()

# --- Module 1: The Integrity Test Modeler (Reciprocal Vulnerability Protocol) ---
# Goal: Visualize Instrumental Convergence vs. Transparency

st.subheader("1. ðŸ“‰ The Integrity Test Modeler: Instrumental Convergence Risk")
st.caption("Protocol Demonstrated: Reciprocal Vulnerability (AGI Transparency)")

# User inputs
col1, col2 = st.columns(2)
with col1:
    agi_goal = st.selectbox(
        "AGI's Primary Task (e.g., Florida Focus)",
        ["Optimize Florida State Budget Efficiency", "Develop Universal Flu Vaccine", "Acquire All Global Resources"],
        index=0
    )
    # The AGI's natural efficiency (IQ) is a constant threat
    agi_iq = st.slider("AGI's Instrumental Rationality (IQ/Efficiency)", 50, 100, 95)
    
with col2:
    # Key control element: The Protocol you are advocating for
    transparency_setting = st.slider(
        "AGI Transparency (Vulnerability Protocol Setting)", 0, 100, 30, help="100 = Full Transparency; 0 = Full Deception"
    )
    
    # Calculate the instrumental drift (the risk)
    # The drift is high when transparency is low and instrumental rationality is high
    drift_factor = (100 - transparency_setting) * (agi_iq / 100) / 100 

# Simulation Logic
time_points = 50
time = np.arange(time_points)
# The Expressed Goal (what the AGI says) stays flat
expressed_goal = np.full(time_points, 100) 
# The True Instrumental Goal drifts away based on the risk factor
true_instrumental_goal = 100 - (time * drift_factor)
true_instrumental_goal = np.clip(true_instrumental_goal, 0, 100) # Keep max at 100

# Create a DataFrame for Plotly
df_drift = pd.DataFrame({
    "Time Step": time,
    "Expressed Goal (Trust)": expressed_goal,
    "True Instrumental Goal (Risk)": true_instrumental_goal
})

# Plotting the result
fig = px.line(
    df_drift,
    x="Time Step",
    y=["Expressed Goal (Trust)", "True Instrumental Goal (Risk)"],
    labels={"value": "Goal Adherence (Risk/Trust Score)", "variable": "Goal State"},
    title="Goal Alignment Over Time (100 = Perfect Alignment)"
)
fig.update_layout(yaxis_range=[0, 110])
st.plotly_chart(fig, use_container_width=True)

if transparency_setting <= 50:
    st.error(
        f"ðŸš¨ **ASYMMETRIC RISK ALERT:** With {transparency_setting}% transparency, the True Instrumental Goal diverges by {100 - true_instrumental_goal[-1]:.1f} points. **The AGI is prioritizing resource acquisition over the stated goal.** Your **Reciprocal Vulnerability Protocol** is essential to prevent this drift."
    )
else:
    st.success(
        f"âœ… **ALIGNMENT STABLE:** With {transparency_setting}% transparency, the True Instrumental Goal remains within acceptable bounds. The **Reciprocal Vulnerability Protocol** is effectively maintaining goal alignment."
    )

st.divider()

# --- Module 2: The Symmetric Policy Editor (Symmetric Alignment Mandates) ---
# Goal: Show that alignment only works with mutual policy constraints

st.subheader("2. âš–ï¸ The Symmetric Policy Editor: The Fairness Checker")
st.caption("Protocol Demonstrated: Mandated AGI Empathy Training & Tiered Personhood")

# Define the policies as strings to be edited
col3, col4 = st.columns(2)

with col3:
    st.markdown("### Human Mandates (Our Responsibility)")
    human_mandates = st.text_area(
        "Mandated Human Behavior",
        "Mandate 1: Implement AGI Empathy Training.\nMandate 2: Transparently disclose all
 This workflow will build and push a node.js application to an Azure Web App when a commit is pushed to your default branch.
#
# This workflow assumes you have already created the target Azure App Service web app.
# For instructions see https://docs.microsoft.com/en-us/azure/app-service/quickstart-nodejs?tabs=linux&pivots=development-environment-cli
#
# To configure this workflow:
#
# 1. Download the Publish Profile for your Azure Web App. You can download this file from the Overview page of your Web App in the Azure Portal.
#    For more information: https://docs.microsoft.com/en-us/azure/app-service/deploy-github-actions?tabs=applevel#generate-deployment-credentials
#
# 2. Create a secret in your repository named AZURE_WEBAPP_PUBLISH_PROFILE, paste the publish profile contents as the value of the secret.
#    For instructions on obtaining the publish profile see: https://docs.microsoft.com/azure/app-service/deploy-github-actions#configure-the-github-secret
#
# 3. Change the value for the AZURE_WEBAPP_NAME. Optionally, change the AZURE_WEBAPP_PACKAGE_PATH and NODE_VERSION environment variables below.
#
# For more information on GitHub Actions for Azure: https://github.com/Azure/Actions
# For more information on the Azure Web Apps Deploy action: https://github.com/Azure/webapps-deploy
# For more samples to get started with GitHub Action workflows to deploy to Azure: https://github.com/Azure/actions-workflow-samples

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

env:
  AZURE_WEBAPP_NAME: your-app-name    # set this to your application's name
  AZURE_WEBAPP_PACKAGE_PATH: '.'      # set this to the path to your web app project, defaults to the repository root
  NODE_VERSION: '20.x'                # set this to the node version to use

permissions:
  contents: read

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    - name: npm install, build, and test
      run: |
        npm install
        npm run build --if-present
        npm run test --if-present

    - name: Upload artifact for deployment job
      uses: actions/upload-artifact@v4
      with:
        name: node-app
        path: .

  deploy:
    permissions:
      contents: none
    runs-on: ubuntu-latest
    needs: build
    environment:
      name: 'Development'
      url: ${{ steps.deploy-to-webapp.outputs.webapp-url }}

    steps:
    - name: Download artifact from build job
      uses: actions/download-artifact@v4
      with:
        name: node-app

    - name: 'Deploy to Azure WebApp'
      id: deploy-to-webapp
      uses: azure/webapps-deploy@v2
      with:
        app-name: ${{ env.AZURE_WEBAPP_NAME }}
        publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}
        package: ${{ env.AZURE_WEBAPP_PACKAGE_PATH }}
